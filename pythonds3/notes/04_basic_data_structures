-----------------------------------------------------------------------------
| CHAPTER 4 - BASIC DATA STRUCTURES                                         |
-----------------------------------------------------------------------------

- Linear Data Structures

    - We'll look at 4 examples of linear data structures, whose items are ordered depending on how they
        were added and removed:

        1. Stacks
        2. Queues
        3. Deques
        4. Lists



- Stacks

    - Stacks are LIFO data structures.  Newer items are near the top, while older items are near the
        base.  Imagine a stack of plates or cafeteria trays.


    - When you put items on the stack, then remove them back off, they are returned in the reverse order
        of which they were inserted.  

      For instance, web browsers store browsing history as a stack to enable the back button.



- The Stack ADT

    - Here are the stack operations:

        Stack()              # Creates a new empty stack

        push(item)           # Adds a new item to the top of the stack

        pop()                # Removes the top item from the stack

        peek()               # Returns the top item from the stack but does not remove it

        is_empty()           # Tests to see whether the stack is empty

        size()               # Returns the number of items on the stack



- Implementing a Stack

    - We'll use a list to implement a stack in Python, since both 'append' and 'pop' operations are O(1).

        class Stack:
            def __init__(self):
                self._items = []

            def is_empty(self):
                return not bool(self._items)

            def push(self, item):
                self._items.append(item)

            def pop(self):
                return self._items.pop()

            def peek(self):
                return self._items[-1]

            def size(self):
                return len(self._items)



- Balanced Parentheses Checking

    - We can use a stack to efficiently check whether parentheses are balanced in a statement.

        def check_parentheses(symbol_string):
            s = Stack()

            for symbol in symbol_string:
                if symbol == '(':
                    s.push(symbol)
                else:
                    if s.is_empty():
                        return False
                    else:
                        s.pop()

            return s.is_empty()



- More General Balanced Symbol Checking

    - We can expand our implementation to handle different kinds of symbols:

        def matches(sym_left, sym_right):
            all_lefts = "([{"
            all_rights = ")]}"
            return all_lefts.index(sym_left) == all_rights.index(sym_right)



- Converting Decimal Numbers to Binary Numbers

    - We can get the binary representation of any integer by continually dividing the number by 2 and
        keeping track of the remainder.  Each remainder is put onto the stack.

      Then, we can pop each number back off the stack, and we'll have our full binary representation.


    - Here is the implementation:

        def divide_by_2(decimal_num):
            rem_stack = Stack()

            while decimal_num > 0:
                rem = decimal_num % 2
                rem_stack.push(rem)
                decimal_num = decimal_num // 2

            bin_string = ""
            while not rem_stack.is_empty():
                bin_string = bin_string + str(rem_stack.pop())

            return bin_string



- Expanding To Convert Any Base

    - Here, we expand the implementation so that we can convert a decimal number to any base from 2-16.

        def base_converter(decimal_num, base):
            digits = "0123456789ABCDEF"
            rem_stack = Stack()

            while decimal_num > 0:
                rem = decimal_num % base
                rem_stack.push(rem)
                decimal_num = decimal_num // base

            new_string = ""
            while not rem_stack.is_empty():
                new_string = new_string + digits[rem_stack.pop()]

            return new_string



- Infix, Prefix, and Postfix Expressions

    - If you write an arithmetic expression such as 'B * C', we have the operator * in between B and C.
        This is called an 'infix expression', since the operator is 'in between' the operands.


    - Note that once we have expressions like 'A + B * C', there may be ambiguity about precedence.
        One way to solve this would be to use a fully parenthesized expression, like '(A + (B * C))'.


    - 'Prefix expressions' require that all operators precede the two operands, like '+ A * B C'.


    - 'Postfix expressions' require the operator to come after the operands, like 'A B C * +'.



- Converting Infix Expressions to Prefix and Postfix

    - One technique for converting an infix to prefix or postfix is to convert the infix notation to 
        a fully parenthesized expression based on operator precedence.

      Then, we can easily convert it to prefix or postix.


    - To convert an infix expression to postfix, we create a stack.  We iterate through the statement,
        split on the tokens, and:

        1. If the token is an operand, add it to the end of the output list.

        2. If the token is a left parentheses, push it onto the stack.

        3. If the token is a right parentheses, pop from the stack until the left parentheses is
             removed.  Add each operator that gets popped off to the end of the output list.

        4. If the token is an operator, push it onto the stack.  However, first remove any operators
             already on the top of the stack with equal or higher precedence and append them to the
             output list.

      Then, at the end, if there are any operators left on the stack, append them to the output list.


    - This algorithm is implemented in 'ch04/statement_conversion.py'.



- Postfix Evaluation

    - To evaluate a statement in postfix notation:

        Create a stack and split the expression into tokens.  Then, for each token:

          1. If the token is an operand, push it onto the stack.

          2. If the token is an operator, it will need 2 operands, so pop from the stack twice.  The
               first pop is the second operand, and the second pop is the first operand.

             Perform the operation and push the result to the stack.

        When the expression is completely processed the result will be the remaining value on the stack.


    - This algorithm is implemented in 'ch04/statement_conversion.py'.



- Queues

    - A queue is an ordered collection of items where the addition of items happens at one end (the back)
        and removal happens from the front end (the front).  It is a FIFO data structure.


    - Common uses include printing queues, OS scheduling algorithms, and typeahead searches.



- The Queue ADT

    - Queues are FIFO data structures.  Here are the queue operations:

        Queue()              # Creates a new empty queue

        enqueue(item)        # Adds a new item to the rear of the queue

        dequeue()            # Removes the front item from the queue

        is_empty()           # Tests to see whether the queue is empty

        size()               # Returns the number of items in the queue



- Implementing a Queue in Python

    - We can use a Python list, and use position 0 in the list as the front of the queue.  This will
        give us O(n) enqueues and O(1) dequeues.


        class Queue:
            def __init__(self):
                self._items = []

            def is_empty(self):
                return not bool(self._items)

            def enqueue(self, item):
                self._items.insert(0, item)

            def dequeue(self):
                return self._items.pop()

            def size(self):
                return len(self._items)



- Deques

- Linked Lists

- Ordered Lists

