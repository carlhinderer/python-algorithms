-----------------------------------------------------------------------------
| CHAPTER 4 - BASIC DATA STRUCTURES                                         |
-----------------------------------------------------------------------------

- Linear Data Structures

    - We'll look at 4 examples of linear data structures, whose items are ordered depending on how they
        were added and removed:

        1. Stacks
        2. Queues
        3. Deques
        4. Lists



- Stacks

    - Stacks are LIFO data structures.  Newer items are near the top, while older items are near the
        base.  Imagine a stack of plates or cafeteria trays.


    - When you put items on the stack, then remove them back off, they are returned in the reverse order
        of which they were inserted.  

      For instance, web browsers store browsing history as a stack to enable the back button.



- The Stack ADT

    - Here are the stack operations:

        Stack()              # Creates a new empty stack

        push(item)           # Adds a new item to the top of the stack

        pop()                # Removes the top item from the stack

        peek()               # Returns the top item from the stack but does not remove it

        is_empty()           # Tests to see whether the stack is empty

        size()               # Returns the number of items on the stack



- Implementing a Stack

    - We'll use a list to implement a stack in Python, since both 'append' and 'pop' operations are O(1).

        class Stack:
            def __init__(self):
                self._items = []

            def is_empty(self):
                return not bool(self._items)

            def push(self, item):
                self._items.append(item)

            def pop(self):
                return self._items.pop()

            def peek(self):
                return self._items[-1]

            def size(self):
                return len(self._items)



- Balanced Parentheses Checking

    - We can use a stack to efficiently check whether parentheses are balanced in a statement.

        def check_parentheses(symbol_string):
            s = Stack()

            for symbol in symbol_string:
                if symbol == '(':
                    s.push(symbol)
                else:
                    if s.is_empty():
                        return False
                    else:
                        s.pop()

            return s.is_empty()



- More General Balanced Symbol Checking

    - We can expand our implementation to handle different kinds of symbols:

        def matches(sym_left, sym_right):
            all_lefts = "([{"
            all_rights = ")]}"
            return all_lefts.index(sym_left) == all_rights.index(sym_right)








- Converting Decimal Numbers to Binary Numbers


- Queues

    - Queues are FIFO data structures.  Here are the queue operations:

        Queue()              # Creates a new empty queue

        enqueue(item)        # Adds a new item to the rear of the queue

        dequeue()            # Removes the front item from the queue

        is_empty()           # Tests to see whether the queue is empty

        size()               # Returns the number of items in the queue



- Deques

- Linked Lists

- Ordered Lists