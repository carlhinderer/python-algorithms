-----------------------------------------------------------------------------
| CHAPTER 3 - ANALYSIS                                                      |
-----------------------------------------------------------------------------

- Timing a Function

    - Here, we create a function that keeps track of how long it takes to execute.

        import time

        def sum_of_n(n):
            start = time.time()

            sum = 0
            for i in range(1, n+1):
                sum = sum + i

            end = time.time()
            elapsed = end - start

            return sum, elapsed


    - Now, we can use this to see how long it takes us to sum the first 10,000 integers.

        for i in range(5):
            print("Sum is %d required %10.7f seconds" % sum_of_n_2(10000))


    - As we add larger and larger values of 'n', we can see that this algorithm does indeed run in
        linear time.


    - Now, we'll add a better implementation, which runs in constant time.

        def sum_of_n_2(n):
            return (n * (n + 1)) / 2



- Common Big-O Functions

    f(n)                 Name
    -----------------------------------------------
     1                   Constant

     log n               Logarithmic

     n                   Linear

     n log n             Log Linear

     n**2                Quadratic

     n**3                Cubic

     2**n                Exponential



- Anagrams

    - One string is an anagram of another if the second string is just a rearrangement of the first.

        heart & earth
        python & typhon


    - For this example, we'll assume the strings are always the same length and from the set of
        lowercase letters.


    - Code located at 'src/ch03/anagram.py'.



- Anagram Detection - Solution 1: Checking Off

    - We move through the first string, checking off each character by setting it to None if it
        exists.  Since strings are immutable, we cast the string to a list to do this.

    - Since we check all the characters in s2 for each character in s1, the running time is 
        O(n**2).



- Solution 2: Sort and Compare

    - Just sort both strings, then compare them one character at a time.

    - Since we have to sort the strings, the running time is O(n lg n).



- Solution 3: Brute Force

    - We could try to solve this problem with brute force by generating all the possible strings from
        s1, and seeing if we get s2.

    - This will generate n! possible strings for s1, so the running time is O(n!), which is even larger
        than O(2**n).



- Solution 4: Count and Compare

    - If 2 strings are anagrams, they have the same number of a's, same number of b's, etc.

    - Since there are only 26 possible characters, we'll create a dictionary with all the characters
        and move through each string, making the counts.  Afterwards, we'll compare the dictionaries.

    - The running time for this algorithm is T(n) = 2n + 26.  This is O(n).



- Performance of Python Lists

    - 

- Big-O Efficiency of Python List Operations

        Operation                    Big-O Efficiency
        --------------------------------------------------
        index []                     O(1)

        index assignment             O(1)

        append                       O(1)

        pop()                        O(1)

        pop(i)                       O(n)

        insert(i, item)              O(n)

        del operator                 O(n)

        iteration                    O(n)

        contains (in)                O(n)

        get slice [x:y]              O(k)

        del slice                    O(n)

        set slice                    O(n+k)

        reverse                      O(n)

        concatenate                  O(k)

        sort                         O(n log n)

        multiply                     O(nk)



- Performance of Python Dictionaries



- Big-O Efficiency of Python Dictionary Operations

        Operation                    Big-O Efficiency
        --------------------------------------------------
        copy                         O(n)

        get item                     O(1)

        set item                     O(1)

        delete item                  O(1)

        contains (in)                O(1)

        iteration                    O(n)