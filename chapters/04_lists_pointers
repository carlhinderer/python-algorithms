--------------------------------------------------------
CH 4 - LISTS AND POINTER STRUCTURES
--------------------------------------------------------

- Arrays

    Arrays are sequential lists of data.  Each element is stored right after the previous
      one in memory.  If the array is really big and you are low on memory, this could
      be a problem.  However, accessing individual elements in them can easily be done
      in constant time.



- Pointer Structures

    Pointer structures can be spread out in memory, because each item contains links to
      other items in the structure.  Their biggest advantages are that they don't require
      sequential storage space, and they can start small and grow bigger as you need 
      them to.



- Simple Node Class

    class Node:
        def __init__(self, data=None):
            self.data = data
            self.next = None

        def _str_(self):
            return str(data)



- Types of Lists

    There are 3 types of lists:
      1. Singly linked list
      2. Doubly linked list
      3. Circular linked list



- Singly linked lists

    >>> n1 = Node('eggs')
    >>> n2 = Node('ham')
    >>> n3 = Node('spam')

    >>> n1.next = n2
    >>> n2.next = n3

    >>> current n1
    >>> while current:
            print(current.data)
            current = current.next



- Singly linked list class

    class SinglyLinkedList:
        def __init__(self):
            self.tail = None        # Tail is first node in our list

        def append(self, data):
            node = Node(data)
            if self.tail = None
                self.tail = node
            else:
                current = self.tail
                while current.next:
                    current = current.next
                current.next = node


    # Create a list
    >>> words = SinglyLinkedList()
    >>> words.append('egg')
    >>> words.append('ham')
    >>> words.append('spam')

    # Traverse the list
    >>> current = words.tail
    >>> while current:
            print(current.data)
            current = current.next



- Faster append operation

    The naive implementation of appending runs in O(n) time.  In order to make it run in
      O(1) time, we keep track of both the head and tail of the list.


    def SinglyLinkedList:
        def __init__(self, data):
            self.head = None          # Head is the last node in our list
            self.tail = None

        def append(self, data):
            node = Node(data)
            if self.head:
                self.head.next = node
                self.head = node
            else:
                self.tail = node
                self.head = node



- Keeping track of list size

    We could traverse the list to get the size if we want:

    def size(self):
        count = 0
        current = self.tail
        while current:
            count += 1
            current = current.next
        return count


    However, to avoid having the count take O(n) time, we can just keep track of it as we
      go along.

    class SinglyLinkedList:
        def __init__(self):
            ...
            self.count = 0

        def append(self, data):
            ...
            self.size += 1



- Improving list traversal

    To abstract the node class from the client, we can add an iterator for traversing the
      list.

    def iter(self):
        current = self.tail
        while current:
            val = current.data
            current = current.next
            yield val


    # Use the iterator
    for word in words.iter():
        print(word)



- Deleting nodes

    The delete operation takes O(n) time.

    def delete(self, data):
        current = self.tail
        prev = self.tail
        while current:
            if current.data == data:
                if current == self.tail:
                    self.tail = current.next
                else:
                    prev.next = current.next
                self.count -= 1
                return
            prev = current
            current = current.next