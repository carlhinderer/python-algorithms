--------------------------------------------------------
CH 6 - TREES
--------------------------------------------------------

- Trees

    A tree is a hierarchical data structure.  

      Root Node    = Top node in the tree all other nodes are attached to, every tree has
                     exactly one root node

      Sub-tree     = A tree whose nodes are a descendant of some other tree

      Degree       = Total number of children of a given node
      (of a node)

      Leaf Node    = A node that doesn't have any children, a terminal node of the tree,
                     degree is always zero

      Edge         = Connection between any 2 nodes, maximum total number of edges in a tree is
                     (number_of_nodes - 1)

      Parent       = A node in the tree which has a further sub-tree is the parent node of that
                     sub-tree

      Child        = A node connected to its parent

      Sibling      = All nodes with the same parent are siblings

      Level        = Root is at node 0, each layer below it is incremented by 1

      Height       = Total number of nodes in the longest path of the tree

      Depth        = The depth of a node is the number of edges from the root of the tree to 
                     that node



- Tree Nodes

    - A tree should never have cycles.

    - A tree with no nodes is an 'empty tree'.

    - A 'binary tree' is a tree in which all nodes have 0, 1, or 2 children.

    - A tree is a 'full binary tree' if all nodes have either 0 or 2 children.

    - A tree is a 'complete binary tree' if it is completely filled, except for
        the bottom level, which is filled in left to right.



- Binary tree nodes

    class Node:
        def _init__(self, data):
            self.data = data
            self.left_child = None
            self.right_child = None


    # Create binary tree nodes
    >>> n1 = Node("root node")  
    >>> n2 = Node("left child node") 
    >>> n3 = Node("right child node") 
    >>> n4 = Node("left grandchild node")

    # Connect nodes with edges
    >>> n1.left_child = n2 
    >>> n1.right_child = n3 
    >>> n2.left_child = n4 

    # Traverse the left side of the tree
    >>> current = n1
    >>> while current:
            print(current.data)
            current = current.left_child



- Depth-first traversal

    In depth-first traversal, we traverse the tree by starting at the root, and go deeper
      into the tree as much as possible on each child, then continue to traverse the next
      sibling.

    There are 3 forms of depth-first traversal:
      1. In-order traversal
      2. Pre-order traversal
      3. Post-order traversal



- In-order traversal

    With in-order traversal, we follow these steps:
      1. We start traversing the left sub-tree and call the 'inorder' function recursively
      2. Next, we visit the root node
      3. Finally, we traverse the right sub tree and call the 'inorder' function recursively
    

    def inorder(self, root_node):
        current = root_node
        if current is None: return
        self.inorder(current.left_child)
        print(current.data)
        self.inorder(current.right_child)



- Infix notation and expression trees

    'Infix notation' (aka 'reverse polish notation') is used to express arithmetic
      expressions where the operators are placed in between the operands.

      4 + 5


    An 'expression tree' is a special kind of binary tree that can be used to represent
      arithmetic expressions.  An in-order traversal of this tree produces an infix
      notation.

        +
       / \
      4   5