--------------------------------------------------------
CH 2 - DATA TYPES AND STRUCTURES
--------------------------------------------------------

- Sequence Methods

    len(s)           # Returns number of elements in s
    min(s)           # Returns minimum value in s (alphabetical for strings)
    max(s)           # Returns maximum value in s (alphabetical for strings)
    sum(s)           # Returns sum of all elements (or TypeError if not numeric)
    all(s)           # Returns true if all elements in s are True
    any(s)           # Returns true if any element in s is True



- Sequence Operations

    s+r              # Concatenates 2 sequences
    s*n              # Makes n copies of s
    v1,..., vn = s   # Unpacks n variables from s
    s[i:j:stride]    # Returns selected elements
    x in s           # Returns true if x is in s
    x not in s       # Returns true if x is not in s



- Sequence Comparisons

    >>> L1 = [1, 2, 3, 4]
    >>> L2 = [1, 2, 3, 4]
    >>> L3 = [1, 2, 3]

    >>> L1 == L2
    True
    >>> L2 > L3
    True



- Tuples are hashable

    Tuples are hashable, since they are immutable.  This means they can be used as keys
      in dictionaries.

    # Create an empty tuple
    t = tuple()



- Dictionary methods

    len(d)                  # Total number of items in d
    d.clear()               # Removes all items
    d.copy()                # Returns shallow copy
    d.fromkeys(s[,value])   # New dictionary with keys in s and values set to value
    d.get(k[,v])            # Returns d[k] if k is found, otherwise returns v

    d.items()
    d.keys()
    d.values()

    d.pop(k[,default])      # Returns d[k] and removes it from d
    d.popitem()             # Returns a random item and removes it from d
    d.setdefault(k[,v])     # Returns d[k]. If not found, retunrs v and sets d[k] to v
    d.update(b)             # Adds all the items from to d



- Sorting dictionaries

    >>> d = {'one': 1, 'two': 2, 'three': 3, 'four': 4}

    # Sorted list of keys
    >>> sorted(list(d))
    ['four', 'one', 'three', 'two']

    # Sorted list of values
    >>> sorted(list(d.values())
    [1, 2, 3, 4]

    # Sorted list of keys according to values
    >>> sorted(list(d), key = d.__get__item)
    ['one', 'two', 'three', 'four']

    # Sort in reverse order
    >>> sorted(list(d), key = d.__get__item, reverse=True)
    ['four', 'three', 'two', 'one']

    # Use list comprehension to get sorted list of values according to keys
    >>> [value for (key, value) in sorted(d.items())]
    [4, 1, 3, 2]


    # Define a custom sorting method (sorts on last letter of the strings)
    >>> def corder(string): return(string[len(string)-1])
    >>> sorted(d, key=corder)
    ['one', 'three', 'two', 'four']



- Example - Count words in a text file using dictionary

    def wordcount(fname):
        try:
            fhand = open(fname)
        except:
            print('File cannot be opened')
            exit()

        count = dict()
        for line in hand:
            words = line.split()
            for word in words:
                if word not in count:
                    count[word] = 1
                else:
                    count[word] += 1
        return count



- Sets and Frozensets

    Sets are mutable, but the items they contain must be immutable.  This is because all built-in
      immutable types are hashable.

    Frozensets are immutable.


    Methods shared by all sets:

    len(a)
    a.copy()
    a.difference(t)
    a.intersection(t)
    a.union(t)
    a.symmetric_difference(t)  # Returns elements that are in either a or t, but not both

    a.isdisjoint(t)            # Returns True if a and t have no elements in common
    a.issubset(t)
    a.issuperset(t)


    Mutable set methods:

    s.add(item)
    s.discard(item)
    s.remove(item)
    s.pop()                    # Removes arbitrary element and returns it
    s.clear()

    s.difference_update(t)     # Removes all elements in t from s
    s.intersection_update(t)   # Removes elements from s that are not in (s | t)
    s.symmetric_difference_update(t)    # Removes elements from s that are not in (s ^ t)
    s.update(t)                # Appends all items in iterable t to s


    Frozensets:

    # A set cannot be a member of a set, since its mutable
    >>> s1 = {'a', 'b', 3, 4}
    >>> s2 = {'c', 'd', 5, 6}
    >>> s1.add(s2)
    TypeError: unhashable type: 'set'

    >>> s1.add(frozenset(s2))
    >>> s1
    {'a', 'b', 3, 4, frozenset({'c', 'd', 5, 6})}