------------------------------------------------------------------------------------
| CHAPTER 1 - SMALL PROBLEMS                                                       |
------------------------------------------------------------------------------------

- Fibonacci - Recursive Solution

    - Here is a basic implementation with the base case specified.

        def fib2(n):
            if n < 2:
                return n
            return fib(n-2) + fib(n-1)


    - The problem is that the call tree will grow exponentially as n gets larger.  If we
        try calling fib2(50), it will never stop running.



- Fibonacci - Use Memoization

    - 'Memoization' means storing the results of calculations so you don't have to re-compute
        them.

        MEMO = {0: 0, 1: 1}

        def fib3(n):
            if n not in MEMO:
                MEMO[n] = fib3(n-2) + fib3(n-1)
            return MEMO[n]



- Fibonacci - Automatic Memoization

    - Python has a built-in decorator for memoizing any function automagically.  This will work
        exactly the same as 'fib3'.

        from functools import lru_cache

        @lru_cache(maxsize=None)
        def fib4(n):
            if n < 2:
                return n
            return fib4(n-2) + fib4(n-1)



- Fibonacci - Iterative Solution

    - The most performant solution is the good old-fashioned iterative one.

        def fib5(n):
            if n == 0: return n
            last = 0
            next = 1
            for _ in range(1, n):
                last, next = next, last + next
            return next



- Fibonacci - Generator

    - We can use a generator to generate the sequence up to a given value.

        def fib6(n):
            yield 0
            if n > 0: yield 1
            last = 0
            next = 1
            for _ in range(1, n):
                last, next = next, last + next
                yield next